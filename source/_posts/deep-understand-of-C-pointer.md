---
title:  深入理解C指针的内存模型
date: 2017-08-24 16:23:25
categories:
tags: C-pointer
---

#### 变量的内存模型
要了解指针，我们要先来了解一般的变量在内存中是以什么样的形式存在的。也就是这里说要说的变量的内存模型。
首先，我们先用C语言来声明一个变量apple，并对它进行初始化。
```C
int apple = 3;
```
这样一句话在内存中得到的是：
`< apple : 3 >`
取apple，就能拿到apple所对应的数值3。但是apple是我们自己定义的，操作系统是怎样识别apple的呢？操作系统在每一块内存空间中都使用了唯一的数字来作为那一块内存空间的标识符，也就是我们操作系统书里面常说的内存地址。这是操作系统在对我们的内存空间进行管理，所以，每一个变量的内存空间自然是由操作系统来指定的，我们程序员一般不会去指定变量存放的内存空间，我们一般只是声明了变量的名称，也就上面的apple，我们引用变量就用变量的名称，而操作系统则是通过存放变量的内存的地址来引用变量。我们所说的指针，其实就是指的是内存的地址。
上面apple的内存地址对于我们来说并不重要，为了方便表述，我们不妨认为它存在的地址就是1001，所以，我们可以得到：
`< apple(1001) : 3 >`
我们对其进行稍微抽象一下就可以得到变量的内存模型如下所示：
`< Tag(address) | Value >`
所以，多个变量组成的栈就是

`< Tag1(address    ) | Value1 >`
`< Tag2(address + 1) | Value2 >`
`< Tag3(address + 2) | Value3 >`
`< Tag4(address + 3) | Value4 >`
`< Tag5(address + 4) | Value5 >`
`< Tag6(address + 5) | Value6 >`
`< Tag7(address + 6) | Value7 >`
`< Tag8(address + 7) | Value8 >`

#### 常用的操作`&`和`*`
通过apple变量来说明一些常用的操作。
``` C
apple  ==> 3
&apple ==> 1001 
```
直接使用apple就是取到了该内存空间存放的数值3，`&`是取地址操作，就是获取到了该变量apple所在的内存块的内存地址，也就是1001。那`*`操作呢？
我们要先有指针型变量再有`*`操作。所以，我们再加入一个bag变量，来装apple :)
``` C
int apple = 3；
int *bag;
bag = &apple;
```
首先，`int *bag`中的`*`,仅仅是声明bag变量是一个指针型变量，并不具有任何计算和操作的含义。指针型变量应该要用一个内存地址来进行初始化。所以，如果我们要对bag进行声明并初始化的话，应该写成
``` C
int apple = 3；
int *bag  = &apple;
```
而不是
``` C
int apple = 3；
int *bag  = apple;
```
特此提出，因为，我自己也常会犯这种错误。
这时，内存中两个变量如下：
`< apple(1001) : 3    >`
`< bag  (1002) : 1001 >`
这时候，我们可以进行的操作多了一个`*`操作（注意，再啰嗦一次，这里`*`表示的是操作，而`int *bag`中的`*`是标志符，表示bag是指针型变量），是单目运算符，该操作的具体就是取出操作对象中存放的地址所指向的内存空间的数值，是的，有点绕口，教科书称之为间接取值，我们可以跳过这个文字说明，直接看操作结果。
常见的操作的结果为：
``` C
apple  ==> 3
bag    ==> 1001

&apple ==> 1001
&bag   ==> 1002

*bag   ==> *(1001) ==> 3
```
`*bag`就是取出bag中所保存的内存地址所指向的内存空间，也就是1001，所保存的数值，也就是3。

#### 指针的指针，地址的地址
我们接下来再考虑一下一个更加复杂一点点的情况，来加深对指针的认识，这就是指针的指针。我们在上面的代码中加入一个新的变量car。
``` C
int apple = 3;
int *bag  = &apple;
int **car = &bag;
```
同样，`*`号在这里不表示任何操作，只是用`**`来表明这是指针的指针，同时，接下来也没有`int ***`这些数据类型了（笑），我们只需要使用指针的指针不断地嵌套，就可以有无数层的引用了。
上述代码的在内存中的表示情况又是怎么样的呢？
`< apple(1001)  : 3    >`
`< bag  (1002)  : 1001 >`
`< car  (1003)  : 1002 >`
对上面三个变量的一些操作结果如下：
``` C
apple  ==>  3   ;
bag    ==>  1001;
car    ==>  1002;

&apple ==> 1001;
&bag   ==> 1002;
&car   ==> 1003;

*bag   ==> 3;
*car   ==> 1001;
**car  ==> *(*car) ==> *1001 ( ==> *bag ) ==> 3
```

#### 指针的指针典型的例子
我们已经定义了一个int型指针，然后想要将其动态分配内存获得一个动态生成的数组，我们写的代码如下：
``` C
#include <stdio.h>
#include <stdlib.h>

void get_array( int *array, int length, int init_value ){
    int i;
    array = (int *)malloc( length * sizeof(int) );
    for( i = 0; i < length; i++ )
        array[i] = init_value;
    // 随便打印一个数字，看看在函数中内否调用到该数字
    printf("%d\n", array[5]); 
}

int main(){
    int i;
    int *eggs;
    get_array( eggs, 10, 1);
    for( i = 0; i < 10; i++ )
        printf("%d", eggs[1]);

    return 0;
}
```
上面的程序看起来是没有问题的，编译的时候也能够通过，但是在执行的时候，就会报出`Segmentation fault (core dumped)`的错误。原因何在？因为在上面的程序中，首先声明了一个int型的指针变量eggs，然后就赋值给了get_array函数中array（同样也是int指针型变量）,但是在函数中array马上就又被malloc函数返回的内存地址重新赋值了，所以，事实上，malloc分配的内存地址并没有传递到我们所期待的eggs变量中。
想要解决这个问题就要用到指针的指针了，代码修改如下：

``` C
#include <stdio.h>
#include <stdlib.h>

void get_array( int **array, int length, int init_value )
{
    int i;
    *array = (int *)malloc( length * sizeof(int) );
    for( i = 0; i < length; i++ )
        (*array)[i] = init_value;
}

int main()
{
    int i;
    int *eggs;
    get_array( &eggs, 10, 1);
    for( i = 0; i < 10; i++ )
        printf("%d\n", eggs[i]);
    return 0;
}
```
与上面不同的地方是，我们在get_array函数中声明的是一个指针的指针函数，传参的时候也做出了相应的改变。
为什么第二个程序就可以达到理想的效果呢？我们不妨来对第二个程序的进行一下分析。

程序准备就绪，但是还没有开始执行的时候：
`< eggs  (1001) : null >`
`< array (1002) : null >`
`< malloc(1004) : null >`
eggs传参数进去之后，`malloc`函数执行之前：
`< eggs (1001) : null >`
`< array(1002) : 1001 >`
`< malloc(1004): null >`
`malloc`函数执行之后（假设malloc返回的内存地址位1003）：
`< eggs (1001) : 1003 >`
`< array(1002) : 1001 >`
`< malloc(1004): 1003 >`
这一步是关键。`< malloc(1004) : 1003 >`这一块应该没有问题，因为我们已经假设`malloc`函数返回的内存地址就是1003了。问题是`<egg (1001) : 1003 >`
我们先来看那一行代码：
``` C
 *array = (int *)malloc( length * sizeof(int) );
``` 
我们可以得到
`*array ==> *(1001) ==> egg = malloc ==> 1003`
在这一行之前，egg原来是null，然后接收了malloc函数的返回值，指向了一块新的内存空间，内存地址加一，指向下一块空间，这样子可以用作一个一维数组了。
#### 小结
C语言函数要想修改主程序中传入的参数的话，想要修改int型数据，就设置参数为int*型，想要修改int*型参数，就设置参数位int**型。其他各种数据类型同理。




















